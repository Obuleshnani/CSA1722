import heapq
import itertools

class PuzzleNode:
    goal_state = [1, 2, 3, 4, 5, 6, 7, 8, 0]

    def __init__(self, state, parent=None, move=None, depth=0):
        self.state = state
        self.parent = parent
        self.move = move
        self.depth = depth
        self.cost = self.calculate_cost()

    def __lt__(self, other):
        return self.cost < other.cost

    def calculate_cost(self):
        h = self.calculate_heuristic()
        return h + self.depth

    def calculate_heuristic(self):
        return sum(1 if self.state[i] != self.goal_state[i] else 0 for i in range(9))

    def generate_children(self):
        children = []
        zero_index = self.state.index(0)
        row, col = divmod(zero_index, 3)

        for dr, dc, move in [(-1, 0, 'Up'), (1, 0, 'Down'), (0, -1, 'Left'), (0, 1, 'Right')]:
            new_row, new_col = row + dr, col + dc
            if 0 <= new_row < 3 and 0 <= new_col < 3:
                new_index = new_row * 3 + new_col
                new_state = self.state[:]
                new_state[zero_index], new_state[new_index] = new_state[new_index], new_state[zero_index]
                children.append(PuzzleNode(new_state, self, move, self.depth + 1))

        return children

    def get_path(self):
        path = []
        current = self
        while current:
            path.append(current)
            current = current.parent
        return path[::-1]

def solve_puzzle(initial_state):
    initial_node = PuzzleNode(initial_state)
    if initial_node.calculate_heuristic() == 0:
        return initial_node.get_path()

    visited = set()
    frontier = []
    heapq.heappush(frontier, initial_node)

    while frontier:
        current_node = heapq.heappop(frontier)
        visited.add(tuple(current_node.state))

        for child in current_node.generate_children():
            if tuple(child.state) not in visited:
                if child.calculate_heuristic() == 0:
                    return child.get_path()
                heapq.heappush(frontier, child)

    return None

def print_solution(path):
    print("Solution steps:")
    for i, node in enumerate(path):
        print(f"Step {i}: {node.move}")
        print_state(node.state)
        print()

def print_state(state):
    for i in range(0, 9, 3):
        print(state[i:i+3])

if __name__ == "__main__":
    initial_state = [1, 2, 3, 4, 0, 5, 6, 7, 8]  # Example initial state, 0 represents the blank tile
    path = solve_puzzle(initial_state)
    if path:
        print_solution(path)
    else:
        print("No solution found.")
